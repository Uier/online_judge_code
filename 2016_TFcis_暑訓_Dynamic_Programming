2016_TFcis_暑訓_Dynamic_Programming_講師:吳彥德學長

複習：原理、子問題、狀態、重疊、最佳、增降維
例：fib
最佳化例題：116、116變形增維、與DFS的差異
計數例題：369
最佳可疊、計數要完整包含不可疊
狀態的必定相異與必定包含（多半看尾）
bottom-up && top-down
邊界問題

不定型
10198 1234，4視為1
10036 N個數字加或減後是否整除於K
10721 n條m組，每組至多k條
11258 將長數字切成32-bit int加總最大（不往兩邊切
590 N個點間飛K天到目標點最小花費（後效性
10912 嚴格遞增字串序號（加總降維

最大連續和：尾
LIS：尾+多選
LCS：雙尾+加總
LIS變形：重疊+轉性質
LCS轉LIS

找零錢：
背包
降維與背後意義（滾動數組）
常數優化平移01背包（10032
物品有數量的背包（711：1~6元有限個數平分）

最佳矩陣相乘
最佳二元搜尋樹

質數篩法DP（884：N!質因數分解
質數篩法DP（11353：以質因數分解個數比大小
2^n DP（10944 撿松果
2^n DP（10911 組隊
矩陣lg n DP（10518 一維
矩陣lg n DP（10081 二維（滾動指針
矩陣lg n DP（11486 走長城

（最後沒來得及講）709 排版單字塞入每一行，空白越少越好
（最後沒來得及講）10069 B在A子序列出現數
（最後沒來得及講）11081 ab組c（加總降維
（最後沒來得及講）11584 切最少幾段迴文
（最後沒來得及講）11151 刪去最少元素成為迴文
12034 N物間<=>關係
10128 N人排成一列，從前看P人，從後看Q人，排列方法數
給字串A和B，操作是改變i到j的字母為k，求將A變成B的最小操作次數
給M種材料需求量，轉蛋N次，每種材料機率同、數量不限且抽中不影響機率，求材料足夠的機率

附錄：以前暑訓的粗略講義和練習題（大量）

BBS Version:

動態規劃

何謂動態規劃
  - 大問題化為小問題
    （Divide and Conquer）
  - 算過的問題不再計算第二次

動態規劃的好處
  - 節省無謂的重覆計算

節省無謂的重覆計算
  - 費氏數列
    - 呼叫的函數數比本身成長快
    - f[n] = f[n-1] + f[n-2] + 1
    - 無謂的大量運算

費氏數列
  - sample tree

兩種不同的實作方式
  - Bottom up
  - Top down
  - 優勝劣敗依題目而定

Bottom up
  - 由已知推未知
  - 從小問題逐步往下推
  - 通常以迴圈呈現，而小問題必須先完成，因此需建立較完整的資訊。

Bottom up
    f[0] = f[1] = 1;
    for(i=2; i<30; i++)
    {
        f[i] = f[i-1] + f[i-2];
    }

Top down
  - 由大問題化至不能再小，再回溯得解
  - 通常以遞迴方式呈現，只計算會用到的問題，有時計算量較少，但遞迴較慢。

Top down
    int fib(int n)
    {
        if(used[n])
        {
            return dp[n];
        }
        used[n] = 1;
        if(n < 2)
        {
            return dp[n] = 1;
        }
        return dp[n] = dp[n-1] + dp[n-2];
    }

如何使用動態規劃
  - 定義合理的狀態表示法
    - f[n] 代表第 n 項
  - 找出狀態轉移方式
    - f[n] = f[n-1] + f[n-2];
  - 設定邊界條件
    - f[0] = f[1] = 1;

使用動態規劃的條件
  - 原問題最佳當且僅當子問題最佳
  - 無後效性

後效性
  - 若符合同一個狀態的不同情形，有著不同的可轉移狀態時，此狀態有後效性。
  - 去後效性的方式 - 增維

何時使用動態規劃不利
  - 找不到子問題
  - 沒有或很少重疊的子問題
  - 狀態數太大以致記憶體無法負荷
  - 有貪婪等更快速的解法

經典問題
  - 從實例中體會以上特性

經典問題
  - 最大連續元素和
  - 背包問題
  - 最長嚴格遞增子序列
  - 最長共同子序列
  - 最佳矩陣連乘順序
  - 最佳二元搜尋樹

最大連續元素和
  - 給定一個數字序列，試求總和最大的連續段？
  - 即從第 i 到第 j 個元素，將其相加起來得一數 s。求使 s 最大的 i, j 配對。

序列
  - 一個有序的集合
  - 子序列為一序列在任意位置去掉任意多的元素所形成。
  - ABC 之所有子序列為 ABC、AB、AC、BC、A、B、C、以及空序列。

最大連續元素和
  - 例 2 3 -6 7 8 -10 5 2 -7 3
  - 答案為 15
  - 如何求解？

枚舉
    for(i=0, res=-1; i<n; i++)
    {
        for(j=i, s=0; j<n; j++)
        {
            res = max(res, s+=v[i]);
        }
    }

枚舉
  - 最糟是試過所有可能 i, j 配對，複雜度 n^2。
  - 有沒有更快的方式？
  - 觀察枚舉過程，發現…

觀察
  - 當加總到出現負數時，不如不要繼續，從下一個開始絕不會比較糟。
  - 於是發現從第 i 個開始考慮時，加總到 i-1 為止若是負的，不如不要。
  - 又發現同樣從第 i 個開始考慮，後面可以取的最佳情形已經固定。
  - 則當取到 i-1 為止最佳，接上第 i 個後也會是最佳。
  - 滿足無後效性及原問題最佳當且僅當子問題最佳。

動態規劃
  - 設狀態 dp[i] = m 代表以第 i 個元素為結尾元素，最大的連續和為 m。
  - 則 dp[i] = max(dp[i-1], 0) + value[i];
  - 為什麼？
  - dp[k] = 0; (k < 0)
  - 答案為 max(dp[k]) 0 <= k < n
  - 為什麼？
  - 複雜度變成 n 了！

改變一下方式
  - 當跑到第 i 個元素時，i-2 或更前面就用不上了。那乾脆只用一個變數？
  - 用一個變數存到目前為止累積的連續和，或者為負數時設為 0 代表重新開始。

練習時間
  - ACM 10684 - The jackpot
  - ACM 108 - Maximum Sum

背包問題
  - 你有一個可裝 m 公斤的背包，告訴你所有可帶走的物品之重量與價值，
    試求可以帶走物品的最大價值為何？

貪心是不行的
  - 設三物分別：A 物重 5、價 15，B 物重 3、價 8，C 物重 3、價 8，背包載重 6。
  - 比例上最佳為取 A 物，實際上呢？
  - 棄 A 物可得價 16 的 B、C 物，獲利高過只取 A 物。
  - 怎麼辦？

暴搜
  - 每物取與不取，兩種情形；若有 n 物則有 2^n 種情形。
  - 大概 20 物就有 2^20 = 1,048,576 種情形。
  - 夠快嗎？
  - 觀察一下，看有沒有什麼發現…

觀察
  - 同樣取到第 i 物時，後面的情形想必一樣。
  - 這樣一來，取價值最高者即可。
  - 正確嗎？

觀察
  - 背包剩餘重量不相同，能裝的便未必相同。
  - 反例：前面貪心時所用的例子。
  - 設三物分別：A 物重 5、價 15，B 物重 3、價 8，C 物重 3、價 8，背包載重 6。
  - 取到 B 物時最佳價值是 15，但重量卻只剩 1！顯然並非最佳解。
  - 有後效性！怎麼辦？增維！

觀察
  - 可知同樣取到第 i 物、總重 w 時，後面的情形完全一樣。
  - 增加了重量，於是消除了後效性。
  - DFS 在相同重量的情形下，如果價值不同呢？只好繼續往下搜…
  - 但價值低者有搜的必要嗎？沒有！
  - 相同條件下，只保留價值最高者。
  - 原問題最佳當且僅當子問題最佳！

動態規劃
  - 以狀態 dp[i][j] = k 表示取第 i 物、不取超過 i、總重和 j 時，最佳價值 k。
  - dp[i][j] = max(dp[m][j-w[i]]) + v[i]; for 0 <= m < i
  - 為什麼？邊界條件又該怎麼處理？
  - 若要求最佳價值下，是取哪些東西，怎麼辦？
  - 從哪裡來，就回哪裡去。

進化版動態規劃
  - n 物品，總重 k，則複雜度 n*k*n = n^2 * k
  - 前面的方法欲求解，需枚舉所有重量以及最後一個物品，有沒有辦法不枚舉呢？
  - 換個狀態試試。

改變狀態
  - 以狀態 dp[i][j] = k 表示前 i 物任意取、總重和 j 時，最佳價值 k。
  - dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]);
  - 為什麼？
  - 這樣求解依舊得枚舉所有重量，能不能再簡化些？

再次改變狀態
  - 以狀態 dp[i][j] = k 表示前 i 物任意取、總重和 <= j 時，最佳價值 k。
  - dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i], dp[i][j-1]);
  - 神奇吧？一樣的表示方式，換個狀態的解釋方式，結果差這麼多。

第三次改變狀態
  - 反正在第 i 物時，自 i-2 物以下的情形都用不上了。那還要保留嗎？
  - 只需保留兩個陣列，一為 i，另一為 i-1，然後一直交叉就可以了。
  - 用指標可避免大量資料搬移，設兩陣列 a, b 用指標 p = a, q = b;
  - 交換時 t = p, p = q, q = t;

第四次改變狀態
  - 將第一次改變的狀態縮為 dp[j] = k 表示總重和 j 的最佳價值 k 行不行？
  - 枚舉 n 物，逐一累加；則在 i-1 物換到 i 物時，狀態 dp[i-1][j]
    自動轉成 dp[i][j]，直接與 dp[j-w[i]] + v[i] 取最佳者，便和上述一樣。
  - 這樣只要一排，就可以完成了。
  - 想想看，這樣會出現什麼問題？如何解決？

第四次改變狀態
  - 試想放第一物的情形，會變成第一物的數量成為無限。
  - 倒著做可以完美解決。
  - 從這個方向去想，第二次改變後，總重和變成 <= j 的狀態表示法，可以縮嗎？

延伸
  - 給 n 物品及其重量，試問能否湊出重量恰為 m 的組合？
  - 想想看，怎麼做？

練習時間
  - ACM 624
  - ACM 10664

最長嚴格遞增子序列
  - 給一序列 s，試求其子序列中，元素依序為嚴格遞增順序者，最長長度為何？

暴搜
  - 每個元素決定刪與不刪，n 個元素就有 2^n 種。
  - 有點慢？
  - 觀察看看…

觀察
  - 取了元素 i，則後面能取的完全相同。
  - 留下取元素 i 所有情形中最佳者，往後取的也會最佳。
  - 為什麼？

動態規劃
  - 設狀態為結尾取到數字大小 m 如何？
  - 有後效性。為什麼？
  - 那設狀態為取到長度 m 如何呢？
  - 有後效性。為什麼？

動態規劃
  - 結尾數字大小 m 有可能出現在不同地方，則前後會影響後面可取元素。
  - 取到長度 m 同樣結尾位置也未必相同。
  - 那麼如果定狀態為結尾元素編號如何？這樣定有無後效性？

動態規劃
  - 設狀態 dp[i] = m 為以第 i 個元素為結尾時，最長嚴格遞增子序列長度 m
  - 轉移方式為何？邊界條件呢？

動態規劃
  - 轉移方式：dp[i] = max(0, dp[j]) + 1 for 0 <= j < i && num[j] < num[i]
  - 複雜度 n^2。
  - 答案為何？

動態規劃
  - 答案：max(dp[i]) for 0 <= i < n。
  - 有沒有辦法像背包問題一樣換狀態？想想看。

改變狀態
  - 考慮：要取的是長度最長的，那麼，如果我們可以依長度大到小，
    只要找到第一個元素比自己小的，就是最佳長度了。
  - 但是排序過於耗時。不過有沒有不用排序的方式？

改變狀態
  - 反正長度成長不會太可怕，如果用類似鍊結串列的方式，把長度相同的串在一起，
    是不是就可以從長度長者看回來？
  - 但是，長度相同的真的有串在一起的必要嗎？

貪心法
  - 一堆數字中，若自己比最小的小，可知一定不會有比自己小的。
  - 能否運用進去呢？

改變狀態
  - 以 dp[p] = q 表示長度 p 的嚴格遞增子序列中，結尾元素最小為 q。
  - 轉移方式較特別，設自己 s，從大的 p 一直枚舉下去，碰到 dp[p] 比 s 小，
    就設 dp[p+1] 為 s。因為 dp[p+1] >= s，所以直接蓋掉至少不會比較差。
  - 若最後答案長度為 m 則複雜度 n*m，m <= n。

加速
  - 觀察發現，若 i > j 則 dp[i] > dp[j]。因為碰到長度小者，就一定接在其後。
  - 因此此數列是由小到大排好的。
  - 可否使用二分搜尋？
  - 複雜度變成 n * log m。

泛用性
  - 如果無法確定當 p < q，則不可接於 p 一定不可接於 q，就不適用這狀態。

練習時間
  - ACM 231
  - ACM 437
  - ACM 481

最長共同子序列
  - 給兩個序列 s1, s2 求最長的共同子序列長度為何？
  - s1, s2 之共同子序列即一序列既為 s1 之子序列，又為 s2 之子序列

枚舉
  - 枚舉所有 s1 的子序列，並檢查是否為 s2 之子序列。
  - 共 2^n 種，每種檢查的複雜度為 n。
  - 有點慢。但是可以觀察一下…

觀察
  - 共同子序列一定包含兩序列相同的元素。
  - 當我取 s1 的第 i 個元素、及 s2 第 j 個元素為共同子序列之一…
  - 則此子序列前面的部份，為 s1 前 i-1 個元素及 s2 前 j-1 個元素，
    所形成之共同子序列。
  - 找到了將大問題化小的方式，而且子問題最佳時，原問題最佳。

動態規劃
  - 以 dp[i][j] = k 代表 s1 使用前 i 個元素、s2 使用前 j 個元素，
    能構成的最長共同子序列。
  - dp[i][j] = (s1[i]==s2[j]) ? dp[i-1][j-1]+1 : max(dp[i-1][j], dp[i][j-1]);
  - 複雜度 n^2。

觀察
  - 前面提及，共同子序列一定包含兩序列相同的元素，也只包含。
  - 那麼列出所有相同元素的配對，共同子序列一定只由這些配對中找出。
  - 並且元素的位置很重要。設兩配對 (a, b), (c, d) 表示 s1[a] == s2[b],
    s1[c] == s2[d]，則要湊在一起，必須 a<c && b<d 才能在同一共同子序列上出現。
  - 列出所有配對，則變成最長遞增子序列問題。
  - 複雜度變為 m log m，其中 m 為配對數。

練習時間
  - ACM 10066
  - ACM 10635

最佳矩陣連乘順序
  - 給 n 個確定可以連乘起來的矩陣，在不對調的情形下，加上括號使得運算次數最少

矩陣相乘
  - 具有結合律，Ax(BxC) = (AxB)xC
  - 一個 a*b 的矩陣和 c*d 的矩陣，僅當 b == c 才可以相乘。
  - 兩個或更多矩陣連乘起來後，會變成一個矩陣，大小為第一個矩陣的第一維
    乘上第二個矩陣的第二維。例：a*b x c*d => a*d 大小
  - 乘法次數 a*b x c*d => a*b*d (or a*c*d)
  - A = 5*2, B = 2*7, C = 7*3.
    (AxB)xC = 5*2*7(AxB) + 5*7*3 = 175
    Ax(BxC) = 2*7*3(BxC) + 5*2*3 = 72  (最佳)

枚舉？
  - 要枚舉倒也不太容易。

觀察
  - 從結果往回推，相乘一次可將兩個矩陣併作一個矩陣，而最後結果僅一個矩陣。
  - 則知最後一步，一定是把兩個矩陣併為一個，這兩個矩陣均為若干矩陣連乘而來。
  - 於是我們可找一個點 k 將這串矩陣從 k 點截斷，將這兩串分別乘起來，
    再把產生出來這兩個矩陣相乘。
  - 於是問題轉變成，如何將這兩串分別乘起來？
  - 這兩個問題，似乎和原問題極為相似…

觀察
  - 切在 k 點乘起來的運算次數為兩串的運算次數，加上合併這兩個矩陣的運算次數。
  - 這兩串連乘之後產生的矩陣不管順序如何都不會變，即合併的次數一定不變。
  - 如何將這兩串乘起來就顯得重要。因此一定是取小者為佳，兩串又互不影響。
  - 找到大問題化小的方式了。但它滿足使用動態規劃的條件嗎？

動態規劃
  - 以 dp[p][q] = r 代表從第 p 個矩陣乘到第 q 個矩陣，要算 r 次乘法。
  - dp[p][q] = min(dp[p][k]+dp[k+1][q]+cost(p, k, q)) for p <= k < q
  - cost(p, k, q) 表示合併矩陣的花費。
  - 想想如果要回溯運算順序，要怎麼做？

練習時間
  - ACM 348

最佳二元搜尋樹
  - 給一個數列，依序代表一個排序好的元素集合，每個元素會被查詢的次數。
    試求一二元搜尋樹，使得將這些元素安排進適當的位置後，
    每個元素查詢次數乘上元素深度總和（稱查詢花費總和）最小。
  - 給 2, 3, 7, 5 代表元素 1 被查詢 2 次，元素 2 被查詢 3 次，…
  - 並且元素 1 < 元素 2 < …

二元搜尋樹
  - 一種二元樹，其節點元素大小恆大於左子樹所有節點，恆小於右子樹所有節點。
  - 中序走訪後恰為排序過之序列。

枚舉？
  - n 個節點的二元樹共有幾種？
  - Catalan 數，並有遞迴式 c[n] = c[n-1] * (4n-2) / (n+1)
  - 大概第 20 項，int 就存不下。
  - 而且也不好枚舉。

觀察
  - 由於是排序過的，所以當我選了一個 root 後，左邊元素一定放左子樹，
    右邊元素也一定放右子樹，而且任一子樹所有元素一定連續。
  - 走訪一定從 root 開始。
  - 當走到左子節點時，發現左子樹所有點走回 root 的深度，只與左子樹結構有關。
  - 因為結構只影響走回左子節點的深度，走回 root 都是深度加 1，相對下沒有影響。
  - 因此當左右子樹亦為最佳二元搜尋樹時，以此 root 形成之二元搜尋樹最佳。
  - 差異只剩決定誰是 root。

動態規劃
  - 以 dp[p][q] = r 代表元素 p 到 q 所組成的二元搜尋樹，其查詢所需花費。
  - dp[p][q] = min(dp[p][k-1]+dp[k+1][q]) + q - p

練習時間
  - ACM 10304

延伸問題
  - ACM 884 - Factorial Factors
  - ACM 674 - Coin Change
  - ACM 714 - Copying Books
  - ACM 10069 - Distinct Subsequences
  - ACM 10036 - Divisibility
  - ACM 709 - Formatting Text
  - ACM 11081 && 10912
  - ACM 10739 - String to Palindrome
  - ACM 10818 - Dora Trip
  - ACM 10635 && 10949
  - ACM 10032 - Tug of War

ACM 884 - Factorial Factors
  - 給數字 n，求 n! 最多可拆成多少 >1 的整數相乘。
  - 可以使用篩法來做雙層 DP，有趣吧？

ACM 674 - Coin Change
  - 求用給定的數種面額硬幣，湊出指定金額的方法數。
  - 類似背包問題，但是物品數量無限。
  - 在 ACM 711 還有有限特定數量的版本。
  - 想想看？

ACM 714 - Copying Books
  - 給一堆書的頁數，以及抄書者 m 位，假設每頁份量相等，且每位抄書者只能抄
    編號連續的書，而不能跳著抄。求如何分配可使得抄最多的人可以抄得儘量少。
  - 當抄最多的人需要抄至多 n 頁時，至多 n+1 頁也可以。
    若需要抄至少 n 頁時，n-1 一定不行。由此可推得需抄的頁數可以二分搜尋之。
  - 對某一特定頁數，檢查是否可行是很簡單的事。此法比 DP 快上相當多。
  - 但仍可拿來思考怎麼去 DP 它。

ACM 10069 - Distinct Subsequences
  - 給兩序列 s1, s2 求 s2 在 s1 中出現幾次。
  - abc 在 abbbc 中出現了三次，分別是前、中、後三種取 b 的方式。
  - 雖然輸入數字大、答案又要大數才存得下，但可思考其 DP 方式。

ACM 10036 - Divisibility
  - 給一數列及一數 k，可在其中兩兩相鄰數之間放加號或減號，試求能否使計算結果
    恰整除於 k。

ACM 709 - Formatting Text
  - 給一篇文章以及指定寬度 w，需將這篇文章以每行長度 w 的方式進行排版。
    單字不得分兩行或更多來顯示，並且每行需以單字開頭、單字結尾，而不能為空白。
    單字間需至少有一個空白，但空白不限個數。對每個排版的評分方式是，
    將單字間的間隔長度平方相加起來。若一行只有一個單字時，則直接加 500。
    分數越低越好，求最佳排版方式，並以該方式輸出這篇文章。
  - 相當漂亮的題目，雖然不太好想。2008 ACM ICPC Regional 越南站曾出現類似題。

ACM 11081 && 10912
  - 善用類似背包問題的方式來改變狀態降維度，會使得複雜度大減的題目。

ACM 10739 - String to Palindrome
  - 迴文形的題目。

ACM 10818 - Dora Trip
  - 經典旅行商問題，求從起點開始遍歷所有點恰一次再回到起點的最小花費。
  - 不過這道題的故事頗有趣，有興趣可以讀讀看。

ACM 10635 && 10949
  - 經典 LCS 的題目。

ACM 10032 - Tug of War
  - 經典以特殊技巧對背包問題降維的漂亮題目。

關於延伸的題目
  - 怕剝奪大家的思考樂趣，就不放正解了。想知道的可以私下詢問。

歡樂練習時間
104
116
147
348
430
431
481
507
559
565
590
607
674
709
711
714
882
884
910
990
10032
10036
10069
10081
10130
10131
10198
10285
10304
10405
10454
10625
10635
10645
10684
10688
10702
10721
10755
10759
10818
10860
10862
10891
10911
10912
10944
10949
11026
11067
11081
11151
11258
11353
11415
